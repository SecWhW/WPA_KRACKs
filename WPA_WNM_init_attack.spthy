theory wpa_wnm_attack_gtk

begin

functions: KDF/1, N/1, snenc/4, sndec/2, S/1, MIC/2
builtins: symmetric-encryption, multiset, natural-numbers
equations: sndec(snenc(message, key, Nonce, IVnat), key) = message

restriction Eq:
    "All x y #i. Eq(x,y) @ i ==> x = y"

restriction Neq:
    "All x y #i. Neq(x,y) @ i ==> not(x = y)"

restriction OnlyOneAssociate:
    "All suppID authID PMK tid1 tid2 #i #j.
		Associate(authID, suppID, tid1, PMK) @ i & Associate(authID, suppID, tid2, PMK) @ j 
		==> #i = #j & tid1 = tid2 "

restriction OnlyOneSupp:
    "All suppID1 suppID2 #i #j.
		Supp_Creat(suppID1) @ i & Supp_Creat(suppID2) @ j 
		==> #i = #j & suppID1 = suppID2 "

restriction OnlyOneAuth:
    "All ID1 ID2 #i #j.
		Auth_Creat(ID1) @ i & Auth_Creat(ID2) @ j 
		==> #i = #j & ID1 = ID2 "

restriction OnlyOnePMK:
    "All PMK1 PMK2 #i #j.
		PMK_Gen(PMK1) @ i & PMK_Gen(PMK2) @ j 
		==> #i = #j & PMK1 = PMK2 "

restriction MemoryCanBeFreedOnlyOnce:
    "All pointer #i #j. Free(pointer) @ i & Free(pointer) @ j ==> #i = #j"

//restriction MemoryCanBeReadOnlyOnce:
//    "All pointer #i #j. Read(pointer) @ i & Read(pointer) @ j ==> #i = #j"

//****************************************************************
/* BEGIN Setup */

rule Supp_Create:
    [ Fr(~suppID) ] 
    --[ Supp_Creat(~suppID) ]-> 
    [ !Supp(~suppID)
    , Out(~suppID) ] 

rule Auth_Create:
    [ Fr(~authID) , Fr(~x) ] 
    --[ Auth_Creat(~authID) ]->
    [ !Auth(~authID) 
    , Out(~authID) ]

rule Auth_Supp_PMK_TID:
	[ Fr(~PMK), !Auth(~authID), !Supp(~suppID)] 
	--[ PMK_Gen(~PMK) ]->
	[!PMKey(~PMK, ~authID, ~suppID, 'NULL')]

rule Auth_Associate_With_Supp:
	let 
		GTK_WNM_Keys = <~gtk2, ~gtk1, ~gtk2, ~wnm1, ~wnm2, ~gtkctr, 1:nat, '1'> 
		/*
		Note that the early official security measures kept only the two keys generated by the GTK handshake, denoted gtk1 and gtk2. The latest security measures also preserve the two keys generated in the WNM operation mode, denoted as wnm1 and wnm2. Here, only early measures are considered.
		*/
	in 
	[ !PMKey(~PMK, ~authID, ~suppID, 'NULL')
	, Fr(~tid), Fr(~gtk1), Fr(~gtk2), Fr(~wnm1), Fr(~wnm2), Fr(~gtkctr)
	, Fr(~ptk), Fr(~oldctr), Fr(~AuthIV), Fr(~SuppIV), Fr(~point),  Fr(~point1), Fr(~Loop), Fr(~Loop1)
	]
    --[ Associate(~authID, ~suppID, ~tid, ~PMK) ]->
    [ AuthGTK('INIT_GTK', ~authID, ~suppID, ~tid, ~ptk, ~oldctr, ~Loop, ~SuppIV, 1:nat, ~AuthIV, 1:nat)
	, SuppGTK('INIT_GTK', ~suppID, ~authID, ~tid, ~ptk, ~oldctr, ~Loop, ~AuthIV, 1:nat, ~SuppIV, 1:nat)
	, AuthWNM('INIT_WNM', ~authID, ~suppID, ~tid, ~ptk, ~oldctr, ~Loop1, ~SuppIV, 1:nat, ~AuthIV, 1:nat)
	, SuppWNM('INIT_WNM', ~suppID, ~authID, ~tid, ~ptk, ~oldctr, ~Loop1, ~AuthIV, 1:nat, ~SuppIV, 1:nat)
	, SuppCom('INIT_Command', ~suppID, ~authID, ~tid, ~ptk, ~gtk2, ~gtkctr, 1:nat)
	, !PMKey(~PMK, ~authID, ~suppID, ~tid), !Auth_GTK_Data('INIT', ~suppID, ~authID, ~tid, ~ptk, GTK_WNM_Keys, ~point1), !Supp_GTK_Data('INIT', ~suppID, ~authID, ~tid, ~ptk, GTK_WNM_Keys, ~point) 
    ]

//*******************************************************************
//We simulate the GTK handshake process twice using a single rule.

rule FasT_Auth_Supp_GTK_1:
	let 
		GTK_WNM_Keys = <gtk2, gtk1, gtk2, wnm1, wnm2, ~gctr, %gIV, '1'>
		New_Keys = <~newgKey2, ~newgKey1, ~newgKey2, wnm1, wnm2, ~gctr, %gIV, '1'>
		//Only the gtk part is updated, the wnm part is not updated
    in
    [ AuthGTK('INIT_GTK', ~authID, ~suppID, ~tid, ~ptk, ~oldctr, ~Loop, ~SuppIV, %SIV, ~AuthIV, %AIV)
	, SuppGTK('INIT_GTK', ~suppID, ~authID, ~tid, ~ptk, ~oldctr, ~Loop, ~AuthIV, %AIV, ~SuppIV, %SIV)
	, !Auth_GTK_Data('INIT', ~suppID, ~authID, ~tid, ~ptk, GTK_WNM_Keys, ~oldpoint)
	, !Supp_GTK_Data('INIT', ~suppID, ~authID, ~tid, ~ptk, GTK_WNM_Keys, ~oldpoint1)
	, Fr(~newgKey1), Fr(~newgKey2), Fr(~newloop), Fr(~newctr), Fr(~newpoint), Fr(~newpoint1)
	, Fr(~newSuppIV), Fr(~newAuthIV)
	]
	--[Fast_Auth_Supp_Reinstalled_TwoGTKs_1(~authID, ~suppID, ~tid, ~ptk, gtk2, New_Keys)
	   , Free(~oldpoint), Free(~oldpoint1) ]->
	[ AuthGTK('INIT_GTK', ~authID, ~suppID, ~tid, ~ptk, ~newctr, ~newloop, ~newSuppIV, 1:nat, ~newAuthIV, 1:nat)
	, SuppGTK('INIT_GTK', ~suppID, ~authID, ~tid, ~ptk, ~newctr, ~newloop, ~newAuthIV, 1:nat, ~newSuppIV, 1:nat)
	, !Auth_GTK_Data('INIT', ~suppID, ~authID, ~tid, ~ptk, New_Keys, ~newpoint)
	, !Supp_GTK_Data('INIT', ~suppID, ~authID, ~tid, ~ptk, New_Keys, ~newpoint1)
	]

rule FasT_Auth_Supp_GTK_2:
	let 
		GTK_WNM_Keys = <gtk1, gtk1, gtk2, wnm1, wnm2, ~gctr, %gIV, '2'>
		New_Keys = <~newgKey1, ~newgKey1, ~newgKey2, wnm1, wnm2, ~gctr, %gIV, '2'>
		//Only the gtk part is updated, the wnm part is not updated.
    in
    [ AuthGTK('INIT_GTK', ~authID, ~suppID, ~tid, ~ptk, ~oldctr, ~Loop, ~SuppIV, %SIV, ~AuthIV, %AIV)
	, SuppGTK('INIT_GTK', ~suppID, ~authID, ~tid, ~ptk, ~oldctr, ~Loop, ~AuthIV, %AIV, ~SuppIV, %SIV)
	, !Auth_GTK_Data('INIT', ~suppID, ~authID, ~tid, ~ptk, GTK_WNM_Keys, ~oldpoint)
	, !Supp_GTK_Data('INIT', ~suppID, ~authID, ~tid, ~ptk, GTK_WNM_Keys, ~oldpoint1)
	, Fr(~newgKey1), Fr(~newgKey2), Fr(~newloop), Fr(~newctr), Fr(~newpoint), Fr(~newpoint1)
	, Fr(~newSuppIV), Fr(~newAuthIV)
	]
	--[Fast_Auth_Supp_Reinstalled_TwoGTKs_2(~authID, ~suppID, ~tid, ~ptk, gtk1, New_Keys)
	  , Free(~oldpoint), Free(~oldpoint1) ]->
	[ AuthGTK('INIT_GTK', ~authID, ~suppID, ~tid, ~ptk, ~newctr, ~newloop, ~newSuppIV, 1:nat, ~newAuthIV, 1:nat)
	, SuppGTK('INIT_GTK', ~suppID, ~authID, ~tid, ~ptk, ~newctr, ~newloop, ~newAuthIV, 1:nat, ~newSuppIV, 1:nat)
	, !Auth_GTK_Data('INIT', ~suppID, ~authID, ~tid, ~ptk, New_Keys, ~newpoint)
	, !Supp_GTK_Data('INIT', ~suppID, ~authID, ~tid, ~ptk, New_Keys, ~newpoint1)
	]

restriction GTK_Reinstalled_TwoGTK_1:
    "All authID suppID tid ptk oldgtk newkeys oldgtk1 newkeys1 #i #j . 
		Fast_Auth_Supp_Reinstalled_TwoGTKs_1(authID, suppID, tid, ptk, oldgtk, newkeys) @ i & 
		Fast_Auth_Supp_Reinstalled_TwoGTKs_1(authID, suppID, tid, ptk, oldgtk1, newkeys1) @ j
		==> (#j = #i)"

restriction GTK_Reinstalled_TwoGTK_2:
    "All authID suppID tid ptk oldgtk newkeys oldgtk1 newkeys1 #i #j . 
		Fast_Auth_Supp_Reinstalled_TwoGTKs_2(authID, suppID, tid, ptk, oldgtk, newkeys) @ i & 
		Fast_Auth_Supp_Reinstalled_TwoGTKs_2(authID, suppID, tid, ptk, oldgtk1, newkeys1) @ j
		==> (#j = #i)"

//*******************************************************************
//The two memory cells gtk1 and gtk2 saved by supplicant are overwritten using the WNM mechanism. //Ultimately bypassing official security measures.

rule Supp_Snd_WNM_Request:
    let 
		M1 = snenc('Request_sleep_Accept_Exit', ~ptk, SuppIV, N(%PIV))
		MIC_M1 = MIC(M1, ~ptk) 
		n1 = (%PIV %+ 1:nat)
    in
    [ SuppWNM('INIT_WNM', ~suppID, ~authID, ~tid, ~ptk, ctr, ~loop, AuthIV, %AIV, SuppIV, %PIV)[+] 
	]
    --[ Supp_Snd_WNM(~suppID, ~authID, ~tid, ~ptk, ~loop)
	  ]->
    [ SuppWNM('Wait_GTK_WNM', ~suppID, ~authID, ~tid, ~ptk, ctr, ~loop, AuthIV, %AIV, SuppIV, n1)
	, Out(<M1, MIC_M1>)]

rule Auth_Snd_WNM_LatestGtk_Command:
    let 
		GTK_WNM_Keys = <gKey, gtk1, gtk2, wnm1, wnm2, gctr, %gIV, kid>
		newgIV = (%gIV %+ 1:nat)
		New_Keys = <gKey, gtk1, gtk2, wnm1, wnm2, gctr, newgIV, kid>
		M1 = snenc('Request_sleep_Accept_Exit', ~ptk, newSuppIV, N(%newPIV))
		MIC_M1 = MIC(M1, ~ptk) 
		M2 = snenc(<'WNM_GTK', gKey, gctr, %gIV, kid>, ~ptk, AuthIV, N(%AIV))
		MIC_M2 = MIC(M2, ~ptk) 
		GtkComm = snenc(<'gtk_data', ~GtkData>, gKey, gctr, %gIV)
		n1 = (%AIV %+ 1:nat)
    in
    [ AuthWNM('INIT_WNM', ~authID, ~suppID, ~tid, ~ptk, ctr, ~loop, SuppIV, %PIV, AuthIV, %AIV)
	, !Auth_GTK_Data('INIT', ~suppID, ~authID, ~tid, ~ptk, GTK_WNM_Keys, ~point)
	, In(<M1, MIC_M1>), Fr(~GtkData), Fr(~newpoint)
	]
    --[ Auth_Snd_WNM_GTK(~authID, ~suppID, ~tid, ~ptk, ~loop, gKey, ~GtkData), Free(~point)
	  ]->
    [ AuthWNM('Done_WNM', ~authID, ~suppID, ~tid, ~ptk, ctr, ~loop, newSuppIV, %newPIV, AuthIV, n1), !Auth_GTK_Data('INIT', ~suppID, ~authID, ~tid, ~ptk, New_Keys, ~newpoint)
	, Out(<M2, MIC_M2>), Out(GtkComm)]

rule Supp_Install_WNM_Gtk:
    let 
		M2 = snenc(<'WNM_GTK', gKey, gctr, %AuthgIV, kid>, ~ptk, newAuthIV, N(%newAIV))
		MIC_M2 = MIC(M2, ~ptk) 
    in
    [ SuppWNM('Wait_GTK_WNM', ~suppID, ~authID, ~tid, ~ptk, ctr, ~loop, AuthIV, %AIV, SuppIV, n1)
	, In(<M2, MIC_M2>)
	]
    --[ Supp_StartInstall_WNM(~suppID, ~authID, ~tid, ~ptk, ~loop, gKey)
	  ]->
    [ SuppWNM('Done_WNM', ~suppID, ~authID, ~tid, ~ptk, ctr, ~loop, newAuthIV, %newAIV, SuppIV, n1)
	, SuppInstallKeys('Install_Keys', ~suppID, ~authID, ~tid, ~ptk, %AuthgIV, ~loop, gKey, kid)
	]

//Checking Keys
rule Supp_Install_WNM_Gtk_1:
    let 
		GTK_WNM_Keys = <gtk, gtk1, gtk2, wnm1, wnm2, gctr, %gIV, '1'>
		new_keys = <gKey, gtk1, gKey, wnm1, wnm2, gctr, %AuthgIV, '1'> 
    in
    [ SuppInstallKeys('Install_Keys', ~suppID, ~authID, ~tid, ~ptk, %AuthgIV, ~loop, gKey, '1')
	, !Supp_GTK_Data('INIT', ~suppID, ~authID, ~tid, ~ptk, GTK_WNM_Keys, ~point)
	, Fr(~newpoint)
	]
    --[ Supp_Install_WNM(~suppID, ~authID, ~tid, ~ptk, ~loop, gKey), Free(~point) 
		, Neq(gKey, gtk1), Neq(gKey, gtk2)
	  ]->
    [ !Supp_GTK_Data('INIT', ~suppID, ~authID, ~tid, ~ptk, new_keys, ~newpoint)
	]

rule Supp_Install_WNM_Gtk_2:
    let 
		GTK_WNM_Keys = <gtk, gtk1, gtk2, wnm1, wnm2, gctr, %gIV, '2'>
		new_keys = <gKey, gKey, gtk2, wnm1, wnm2, gctr, %AuthgIV, '2'> 
    in
    [ SuppInstallKeys('Install_Keys', ~suppID, ~authID, ~tid, ~ptk, %AuthgIV, ~loop, gKey, '2')
	, !Supp_GTK_Data('INIT', ~suppID, ~authID, ~tid, ~ptk, GTK_WNM_Keys, ~oldpoint)
	, Fr(~newpoint)
	]
    --[ Supp_Install_WNM(~suppID, ~authID, ~tid, ~ptk, ~loop, gKey), Free(~oldpoint)
		, Neq(gKey, gtk1), Neq(gKey, gtk2)
	  ]->
    [ !Supp_GTK_Data('INIT', ~suppID, ~authID, ~tid, ~ptk, new_keys, ~newpoint)
	]

rule Auth_Supp_WNM_ReInit:
    [ SuppWNM('Done_WNM', ~suppID, ~authID, ~tid, ~ptk, ctr1, ~loop, newAuthIV, %newAIV, SuppIV, %PIV)  
	, AuthWNM('Done_WNM', ~authID, ~suppID, ~tid, ~ptk, ctr2, ~loop, newSuppIV, %newPIV, AuthIV, %AIV)
	, Fr(~newloop), Fr(~newctr)
	]
    --[ Auth_Supp_GTKReinit(~authID, ~suppID, ~tid, ~loop, ~newloop)
	  ]->
    [ //AuthWNM('INIT_WNM', ~authID, ~suppID, ~tid, ~ptk, S(~newctr), ~newloop, newSuppIV, %newPIV, AuthIV, %AIV)
	//, SuppWNM('INIT_WNM', ~suppID, ~authID, ~tid, ~ptk, S(~newctr), ~newloop, newAuthIV, %newAIV, SuppIV, %PIV) 
	]

rule Supp_Rcv_WNM_Command_Init:
    let 
		GTK_WNM_Keys = <gtk, gtk1, gtk2, wnm1, wnm2, gctr, %gIV1, kid>
		GtkComm = snenc(<'gtk_data', ~GtkData>, gKey, gctr, %gIV)
		newgIV = (%gIV %+ 1:nat)
		new_keys = <gKey, gtk1, gtk2, wnm1, wnm2, gctr, newgIV, kid>
    in
    [ SuppCom('INIT_Command', ~suppID, ~authID, ~tid, ~ptk, gtk, oldgctr, %oldgIV), In(GtkComm)
	, !Supp_GTK_Data('INIT', ~suppID, ~authID, ~tid, ~ptk, GTK_WNM_Keys, ~point), Fr(~newpoint)
	]
    --[ Supp_Rcv_Command(~suppID, ~authID, ~tid, ~ptk, gKey, ~GtkData), Eq(gKey, gtk), Free(~point)
	  ]->
    [ SuppCom('Wait_GTK_Command', ~suppID, ~authID, ~tid, ~ptk, gtk, gctr, newgIV)
	, !Supp_GTK_Data('INIT', ~suppID, ~authID, ~tid, ~ptk, new_keys, ~newpoint)
	]

rule Supp_Rcv_WNM_Command_Repeat:
    let 
		GTK_WNM_Keys = <gKey, gtk1, gtk2, wnm1, wnm2, gctr, %gIV, kid>
		GtkComm = snenc(<'gtk_data', ~GtkData>, gKey, gctr, %gIV)
		newgIV = (%gIV %+ 1:nat)
    in
    [ SuppCom('Wait_GTK_Command', ~suppID, ~authID, ~tid, ~ptk, gtk, gctr, %oldgIV), In(GtkComm), Fr(~newpoint)
	, !Supp_GTK_Data('INIT', ~suppID, ~authID, ~tid, ~ptk, GTK_WNM_Keys, ~point)
	]
    --[ Supp_Rcv_Command_Again(~suppID, ~authID, ~tid, ~ptk, gKey, ~GtkData), Eq(gKey, gtk), Free(~point)
	  ]->
    [ //SuppCom('Wait_GTK_Command', ~suppID, ~authID, ~tid, ~ptk, gKey, gctr, newgIV)
	!Supp_GTK_Data('INIT', ~suppID, ~authID, ~tid, ~ptk, GTK_WNM_Keys, ~newpoint)	]


//*******************************************************************

lemma Association_created [reuse]:
    "All authID suppID tid PMK #i.
	Associate(authID, suppID, tid, PMK) @ i
     ==> (Ex #j. j < i & Auth_Creat(authID) @ j) &
         (Ex #k. k < i & Supp_Creat(suppID) @ k)"

lemma Association_is_unique [reuse, use_induction, heuristic=C]:
    "All authID1 authID2 tID suppID1 suppID2 PMK1 PMK2 #i #j.
     Associate(authID1, suppID1, tID, PMK1) @ i &
     Associate(authID2, suppID2, tID, PMK2) @ j 
     ==> #i = #j"

//An attack is found if this lemma is hold.
lemma gtk_rekeys_attack [use_induction, heuristic=S]:
	exists-trace
	"Ex suppID authID tid ptk gtk GtkData #i #j . (i < j) & 
		Supp_Rcv_Command(suppID, authID, tid, ptk, gtk, GtkData) @ i & 
		Supp_Rcv_Command_Again(suppID, authID, tid, ptk, gtk, GtkData) @ j "


/*
==============================================================================
summary of summaries:

analyzed: WPA_WNM_init_attack.spthy

  Association_created (all-traces): verified (6 steps)
  Association_is_unique (all-traces): verified (4 steps)
  gtk_rekeys_attack (exists-trace): verified (19 steps)

==============================================================================

real    0m15.368s
user    1m39.742s
sys     0m34.948s
*/

end
